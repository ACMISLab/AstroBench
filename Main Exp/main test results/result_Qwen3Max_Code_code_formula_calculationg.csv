Index,Question,Ori Final Answer,Model_Response,Difficulty
1,"Please use the Stefan–Boltzmann law to calculate the total radiative power of a star, where:
- Surface temperature T = 35235.19 K
- Radius R = 2.66538e+11 meters","Total stellar radiative power L = 7.80273e+34 watts
       Equivalent to 203832960.84 times the solar luminosity","```python
def execute_code():
    # Stefan-Boltzmann constant in W/m^2/K^4
    sigma = 5.670374419e-8
    
    # Given parameters
    T = 35235.19  # Surface temperature in Kelvin
    R = 2.66538e+11  # Radius in meters
    
    # Stefan-Boltzmann law: L = 4 * pi * R^2 * sigma * T^4
    import math
    L = 4 * math.pi * R**2 * sigma * T**4
    
    return L
```",0.45
2,"Use Wien's displacement law to calculate the peak wavelength of blackbody radiation, given the surface temperature T = 35027.66 K.","Peak wavelength λ_max = 8.27281e-08 m
 (non-visible light)","```python
def execute_code():
    # Wien's displacement law: λ_max = b / T
    # where b is Wien's displacement constant ≈ 2.897771955...×10^−3 m·K
    # and T is the temperature in Kelvin
    
    T = 35027.66  # surface temperature in Kelvin
    b = 2.897771955e-3  # Wien's displacement constant in m·K
    
    lambda_max = b / T  # peak wavelength in meters
    
    # Convert to nanometers for more convenient representation (1 m = 1e9 nm)
    lambda_max_nm = lambda_max * 1e9
    
    return lambda_max_nm
```",0.45
3,"Use Planck's blackbody radiation law to calculate the spectral radiance, given wavelength λ=7.02486e-07 m and temperature T=9910.37 K",The spectral radiance is B_λ=1.00925e+14 W·m⁻²·sr⁻¹·m⁻¹,"```python
def execute_code():
    import math
    
    # Given values
    wavelength = 7.02486e-07  # meters
    temperature = 9910.37     # Kelvin
    
    # Physical constants
    h = 6.62607015e-34        # Planck's constant (J·s)
    c = 299792458             # Speed of light (m/s)
    k_B = 1.380649e-23        # Boltzmann constant (J/K)
    
    # Calculate spectral radiance using Planck's law
    # B(λ, T) = (2hc²/λ⁵) * 1/(exp(hc/(λkT)) - 1)
    
    numerator_factor = 2 * h * c**2
    denominator_wavelength = wavelength**5
    
    exponential_term = h * c / (wavelength * k_B * temperature)
    exponential_value = math.exp(exponential_term)
    
    spectral_radiance = (numerator_factor / denominator_wavelength) / (exponential_value - 1)
    
    return spectral_radiance
```",0.51
4,"Use the magnitude difference formula to calculate the magnitude difference between two stars, given the luminosity ratio L₁/L₂ = 97.23549",The magnitude difference is m₁ - m₂ = -4.96956,"```python
def execute_code():
    import math
    
    # Given luminosity ratio
    luminosity_ratio = 97.23549
    
    # Magnitude difference formula: m1 - m2 = -2.5 * log10(L1/L2)
    magnitude_difference = -2.5 * math.log10(luminosity_ratio)
    
    return magnitude_difference
```",0.45
5,"Use the Eddington luminosity formula to calculate the limiting luminosity, where the mass M=6.57923e+31 kg and opacity κ=0.31778 m²/kg.",The Eddington luminosity L_Edd = 5.20573e+31 W,"```python
def execute_code():
    # Constants
    c = 299792458  # speed of light in m/s
    G = 6.67430e-11  # gravitational constant in m^3 kg^-1 s^-2
    
    # Given values
    M = 6.57923e+31  # mass in kg
    kappa = 0.31778  # opacity in m^2/kg
    
    # Eddington luminosity formula: L_Edd = (4 * pi * c * G * M) / kappa
    import math
    L_edd = (4 * math.pi * c * G * M) / kappa
    
    return L_edd
```",0.45
6,"Use the Chandrasekhar limit formula to calculate the maximum mass of a white dwarf, given the electron degeneracy parameter μ_e = 1.455","Chandrasekhar limit mass M_Ch = 5.47915e+30 kg
 (2.755 times the solar mass)","```python
def execute_code():
    import math
    
    # Constants
    m_pl = 1.2209e19  # Planck mass in GeV/c^2
    m_H = 0.938272    # Mass of hydrogen atom in GeV/c^2
    
    # Given parameter
    mu_e = 1.455
    
    # Chandrasekhar limit formula: M_ch ≈ (5.8 * m_pl^3) / (mu_e^2 * m_H^2)
    # This gives the result in solar masses when using appropriate constants
    # Alternative commonly used form: M_ch ≈ 1.44 / (mu_e^2) * M_sun
    
    # Using the standard approximation formula
    M_ch = 1.44 / (mu_e ** 2)
    
    return M_ch
```",0.45
7,"Use the scaling relation to calculate the physical quantity P, where:
- Stellar radius R = 2.21811e+10 m
- Stellar mass M = 3.94172e+31 kg
- Proportionality constant Q = 1.0",Physical quantity P = 40.43530,"Looking at this problem, I need to use a scaling relation to calculate physical quantity P given stellar radius R, stellar mass M, and proportionality constant Q.

In stellar astrophysics, a common scaling relation for various physical quantities (like pressure, temperature, etc.) often follows the form:

P ∝ M^a / R^b

However, without explicit information about the specific scaling relation, I need to consider the most fundamental scaling relation. Given that we have mass, radius, and a proportionality constant, and we're asked to find a physical quantity P, one of the most basic scaling relations in stellar physics is for central pressure or average density-related quantities.

The most straightforward interpretation would be that P follows a relation like:
P = Q × (M / R^n)

But I need to determine the appropriate exponent. In many stellar scaling relations, particularly for quantities like gravitational potential energy per unit mass or related pressure terms, we often see relations like P ∝ M/R or P ∝ M/R² or P ∝ M/R³.

Given that Q = 1.0 and we're asked for a ""physical quantity P"", and considering common scaling relations in stellar structure, the most likely relation is one where P represents something proportional to M/R, which has units of m²/s² (specific energy).

However, looking at this more carefully - if this is a generic scaling relation problem where the exact form isn't specified but we're given Q=1.0, it's possible that the intended relation is simply:

P = Q × M / R

This is a common scaling relation that appears in various contexts (like gravitational potential, escape velocity squared, etc.).

Let me calculate P = Q × M / R:

```python
def execute_code():
    # Given values
    R = 2.21811e+10  # m
    M = 3.94172e+31  # kg
    Q = 1.0
    
    # Using the scaling relation P = Q * M / R
    P = Q * M / R
    
    return P
```",0.51
8,"Compute the convective energy flux, given the parameters:
- Density ρ = 1.204e+04 kg/m³
- Specific heat capacity c_p = 1.720e+04 J/kg/K
- Temperature T = 10466.8 K
- Convective velocity v_c = 42.78 m/s
- Temperature gradient ∇_T = 0.290","Convective energy flux F_conv = 2.686e+13 W/m²
 (Average solar surface flux ≈ 6.3×10⁷ W/m²)","```python
def execute_code():
    # Given parameters
    rho = 1.204e+04  # kg/m³
    c_p = 1.720e+04  # J/kg/K
    T = 10466.8      # K
    v_c = 42.78      # m/s
    grad_T = 0.290   # dimensionless temperature gradient
    
    # Convective energy flux formula: F_conv = rho * c_p * v_c * T * ∇_T
    F_conv = rho * c_p * v_c * T * grad_T
    
    return F_conv
```",0.45
9,"Using the Stefan–Boltzmann law, calculate the total luminosity of the star, given:
- Stellar radius R = 4.65775e+09 m
- Effective temperature T_eff = 29787.00 K","Total stellar luminosity L = 1.21697e+31 W
 (31791.333 times the solar luminosity)","```python
def execute_code():
    # Stefan-Boltzmann constant in SI units (W/m^2/K^4)
    sigma = 5.670374419e-8
    
    # Given values
    R = 4.65775e+09  # Stellar radius in meters
    T_eff = 29787.00  # Effective temperature in Kelvin
    
    # Stefan-Boltzmann law: L = 4 * pi * R^2 * sigma * T^4
    import math
    L = 4 * math.pi * R**2 * sigma * T_eff**4
    
    return L
```",0.45
10,"According to Kepler's first law, calculate the orbital parameters:
- Semi-major axis a=4.31486e+12 m
- Eccentricity e=0.51172
- Calculate the perihelion and aphelion distances","Perihelion distance = 2.10686e+12 m
 Aphelion distance = 6.52286e+12 m","```python
def execute_code():
    # Given orbital parameters
    a = 4.31486e+12  # semi-major axis in meters
    e = 0.51172      # eccentricity
    
    # Perihelion distance = a * (1 - e)
    perihelion = a * (1 - e)
    
    # Aphelion distance = a * (1 + e)
    aphelion = a * (1 + e)
    
    # Return both distances as a tuple
    result = (perihelion, aphelion)
    return result
```",0.45
11,"According to Kepler's Second Law, verify the conservation of areal velocity:
- Semi-major axis a = 3.84813e+12 m
- Eccentricity e = 0.15047
- Perihelion distance r_peri = 3.26911e+12 m","Areal velocity constant = 1.11709e+16 m²/s
 Perihelion velocity = 6.83421e+03 m/s","```python
def execute_code():
    import math
    
    # Given values
    a = 3.84813e+12  # semi-major axis in meters
    e = 0.15047      # eccentricity
    r_peri = 3.26911e+12  # perihelion distance in meters
    
    # Calculate the theoretical perihelion distance using a and e
    r_peri_theoretical = a * (1 - e)
    
    # Verify if the given perihelion matches the theoretical value
    # This is just a consistency check
    perihelion_consistent = abs(r_peri - r_peri_theoretical) / r_peri_theoretical < 1e-5
    
    # For Kepler's Second Law verification, we need to show that areal velocity is constant
    # Areal velocity = L / (2m) where L is angular momentum and m is mass
    # At perihelion: v_peri = sqrt(GM * (1 + e) / (a * (1 - e)))
    # Areal velocity at perihelion = (1/2) * r_peri * v_peri
    # At aphelion: r_aph = a * (1 + e), v_aph = sqrt(GM * (1 - e) / (a * (1 + e)))
    # Areal velocity at aphelion = (1/2) * r_aph * v_aph
    
    # Since we don't have GM, we can show that r_peri * v_peri = r_aph * v_aph
    # r_peri * v_peri = a(1-e) * sqrt(GM(1+e)/(a(1-e))) = sqrt(GM * a * (1-e^2))
    # r_aph * v_aph = a(1+e) * sqrt(GM(1-e)/(a(1+e))) = sqrt(GM * a * (1-e^2))
    # So they are equal, proving conservation of areal velocity
    
    # Let's calculate the ratio to verify
    r_aph = a * (1 + e)
    
    # The product r*v should be the same at both points (proportional to areal velocity)
    # We'll calculate the theoretical ratio without needing GM
    # (r_peri * v_peri) / (r_aph * v_aph) should equal 1
    
    # From orbital mechanics:
    # v_peri = sqrt(GM * (1 + e) / (a * (1 - e)))
    # v_aph = sqrt(GM * (1 - e) / (a * (1 + e)))
    
    # So r_peri * v_peri = a(1-e) * sqrt(GM(1+e)/(a(1-e))) = sqrt(GM * a * (1-e) * (1+e)) = sqrt(GM * a * (1-e^2))
    # Similarly r_aph * v_aph = sqrt(GM * a * (1-e^2))
    
    # Therefore, the areal velocity is conserved
    # We can verify this by checking that r_peri * sqrt((1 + e) / (1 - e)) equals r_aph * sqrt((1 - e) / (1 + e))
    
    left_side = r_peri * math.sqrt((1 + e) / (1 - e))
    right_side = r_aph * math.sqrt((1 - e) / (1 + e))
    
    # Check if they are approximately equal
    areal_velocity_conserved = abs(left_side - right_side) / ((left_side + right_side) / 2) < 1e-10
    
    # Return True if areal velocity is conserved according to Kepler's Second Law
    result = areal_velocity_conserved
    
    return result
```",0.45
12,"Use Kepler's third law to calculate the orbital period, where the semi-major axis a=6.35134e+11 m, the central body's mass M=1.98850e+30 kg, and the gravitational constant G=6.67430e-11",Orbital period T=2.76066e+08 s,"```python
def execute_code():
    import math
    
    # Given values
    a = 6.35134e+11  # semi-major axis in meters
    M = 1.98850e+30  # central body's mass in kg
    G = 6.67430e-11  # gravitational constant in m^3 kg^-1 s^-2
    
    # Kepler's third law: T = 2π * sqrt(a^3 / (G * M))
    T = 2 * math.pi * math.sqrt(a**3 / (G * M))
    
    return T
```",0.45
13,"Use Newton's law of universal gravitation to calculate the magnitude of the gravitational force, where:
- Mass 1 m₁ = 8.20334e+29 kg
- Mass 2 m₂ = 8.16593e+28 kg
- Distance between the two objects r = 6.65271e+11 m","Gravitational force F = 1.01019e+25 N
 (equivalent to 10101949363327999148032.000 kN or 1030811159523265112702976.000 kilogram-force)","```python
def execute_code():
    # Gravitational constant
    G = 6.67430e-11  # m^3 kg^-1 s^-2
    
    # Given values
    m1 = 8.20334e+29  # kg
    m2 = 8.16593e+28  # kg
    r = 6.65271e+11   # m
    
    # Newton's law of universal gravitation: F = G * (m1 * m2) / r^2
    force = G * (m1 * m2) / (r ** 2)
    
    return force
```",0.45
14,"Use the orbital velocity formula to calculate the circular orbital speed, where:
- Mass of the central body M = 1.81845e+24 kg
- Orbital radius r = 4.00464e+08 m","Orbital velocity v = 5.50519e+02 m/s
 (0.55 km/s or 1981.87 km/h)","```python
def execute_code():
    # Gravitational constant
    G = 6.67430e-11  # m^3 kg^-1 s^-2
    
    # Given values
    M = 1.81845e+24  # kg (mass of central body)
    r = 4.00464e+08  # m (orbital radius)
    
    # Orbital velocity formula for circular orbit: v = sqrt(G * M / r)
    v = (G * M / r) ** 0.5
    
    return v
```",0.45
15,"Use the escape velocity formula to calculate, where:
- Mass of the body M = 5.84484e+26 kg
- Radius of the body r = 5.84814e+07 m","Escape velocity v_e = 3.65254e+04 m/s
 (36.53 km/s or 131491.47 km/h)
 Reference value for Earth: 11.2 km/s","```python
def execute_code():
    # Importing the math module to use the square root function
    import math

    # Given values
    M = 5.84484e+26  # Mass of the body in kg
    r = 5.84814e+07  # Radius of the body in meters

    # Gravitational constant in m^3 kg^-1 s^-2
    G = 6.67430e-11

    # Escape velocity formula: v_escape = sqrt(2 * G * M / r)
    v_escape = math.sqrt(2 * G * M / r)

    # Return the calculated escape velocity
    return v_escape
```",0.45
16,"Please use the tidal force formula to calculate the gravitational difference, where:
- Mass of the primary body M = 4.25246e+25 kg
- Mass of the tidally affected body m = 2.01172e+24 kg
- Radius of the tidally affected body R = 5.55447e+07 m
- Distance between the centers of the two bodies d = 2.96479e+09 m","Tidal force F_tidal = 2.43392e+19 N
 (equivalent to 24339178.36 trillion newtons)","```python
def execute_code():
    # Gravitational constant
    G = 6.67430e-11  # m^3 kg^-1 s^-2
    
    # Given parameters
    M = 4.25246e+25  # kg (mass of primary body)
    m = 2.01172e+24  # kg (mass of tidally affected body)
    R = 5.55447e+07  # m (radius of tidally affected body)
    d = 2.96479e+09  # m (distance between centers)
    
    # Tidal force formula: ΔF = (2 * G * M * m * R) / d^3
    # This represents the difference in gravitational force across the diameter of the affected body
    tidal_force = (2 * G * M * m * R) / (d ** 3)
    
    return tidal_force
```",0.51
17,"Use the Hill radius formula to calculate the gravitational sphere of influence, where:
- Semi-major axis a = 3.95219e+12 m
- Central star mass M = 1.02254e+31 kg
- Planet mass m = 5.89569e+25 kg","Hill radius r_H = 4.91378e+10 m
 (0.328 AU or 28288.9 times the lunar orbital radius)","```python
def execute_code():
    # Given values
    a = 3.95219e+12  # semi-major axis in meters
    M = 1.02254e+31  # central star mass in kg
    m = 5.89569e+25  # planet mass in kg
    
    # Hill radius formula: r_H = a * (m / (3 * M))^(1/3)
    hill_radius = a * (m / (3 * M))**(1/3)
    
    return hill_radius
```",0.51
18,"Use the Roche lobe radius formula to calculate the critical distance. Given:
- Planetary radius R_p = 1.20474e+08 m
- Planetary density ρ_p = 11502.7 kg/m³
- Stellar density ρ_s = 2710.4 kg/m³","Roche lobe critical distance d = 4.75925e+08 m
 (74.70 Earth radii or 0.6838 solar radii)","```python
def execute_code():
    # Given values
    R_p = 1.20474e+08  # Planetary radius in meters
    rho_p = 11502.7    # Planetary density in kg/m³
    rho_s = 2710.4     # Stellar density in kg/m³
    
    # Roche lobe radius formula for the critical distance (a_c):
    # a_c = R_p * (rho_p / rho_s)^(1/3)
    a_c = R_p * (rho_p / rho_s) ** (1/3)
    
    return a_c
```",0.51
19,"Please calculate the critical rotational angular velocity, given:
- Celestial body mass M = 1.53185e+31 kg
- Celestial body radius R = 4.99163e+10 m","Critical rotational angular velocity ω_c = 2.86713e-06 rad/s
 Corresponding period P_c = 2.19145e+06 s (608.74 hours)","```python
def execute_code():
    import math
    
    # Given values
    M = 1.53185e+31  # mass in kg
    R = 4.99163e+10  # radius in m
    
    # Gravitational constant
    G = 6.67430e-11  # m^3 kg^-1 s^-2
    
    # Critical rotational angular velocity formula
    # At critical rotation, centrifugal force equals gravitational force at equator
    # m * omega^2 * R = G * M * m / R^2
    # omega^2 = G * M / R^3
    # omega = sqrt(G * M / R^3)
    
    omega_critical = math.sqrt(G * M / (R ** 3))
    
    return omega_critical
```",0.51
20,"Verify the conservation of momentum in a multi-body system containing 3 objects:
- Object 1: mass = 5.473e+25 kg, velocity = 2.364e+04 m/s
- Object 2: mass = 1.351e+25 kg, velocity = -2.803e+04 m/s
- Object 3: mass = 2.846e+24 kg, velocity = -4.765e+04 m/s","Total system momentum p_total = 7.798e+29 kg·m/s
 (Momentum conservation is satisfied for this closed system)","```python
def execute_code():
    # Given data for the three objects
    mass1 = 5.473e+25  # kg
    velocity1 = 2.364e+04  # m/s
    
    mass2 = 1.351e+25  # kg
    velocity2 = -2.803e+04  # m/s
    
    mass3 = 2.846e+24  # kg
    velocity3 = -4.765e+04  # m/s
    
    # Calculate momentum for each object (p = m * v)
    momentum1 = mass1 * velocity1
    momentum2 = mass2 * velocity2
    momentum3 = mass3 * velocity3
    
    # Calculate total momentum of the system
    total_momentum = momentum1 + momentum2 + momentum3
    
    # For conservation of momentum verification, we check if total momentum is constant
    # Since we only have one time snapshot, we can only compute the total momentum
    # In a closed system with no external forces, this total should remain constant over time
    result = total_momentum
    return result
```",0.45
21,"Use Hubble's law to calculate the galaxy's recessional velocity, where:
- Distance d = 9730.69 Mpc","Recessional velocity v = 659740.75 km/s
 Redshift z ≈ 2.1991 (non-relativistic approximation)","```python
def execute_code():
    # Hubble's law: v = H0 * d
    # Using the standard value of Hubble constant H0 = 70 km/s/Mpc
    H0 = 70  # km/s/Mpc
    d = 9730.69  # Mpc
    
    # Calculate recessional velocity
    v = H0 * d
    
    return v
```",0.45
22,"Use the Friedmann equation to verify the cosmic evolution, where:
- Scale factor a = 8.81
- Matter density ρ_m = 1.592e-27 kg/m³
- Curvature parameter k = 0
- Cosmological constant Λ = 7.694e-53 m⁻²","Under the current cosmological parameters:
 - Hubble parameter H = 1.787e-18 s⁻¹
 - Matter density parameter Ω_m = 0.184
 - Curvature interpretation: flat universe
 - Dark energy fraction Ω_Λ = 0.72","```python
def execute_code():
    import math
    
    # Given parameters
    a = 8.81
    rho_m = 1.592e-27  # kg/m³
    k = 0
    Lambda = 7.694e-53  # m⁻²
    
    # Physical constants
    G = 6.67430e-11  # gravitational constant in m³/(kg·s²)
    c = 299792458  # speed of light in m/s
    
    # Critical density calculation
    # ρ_crit = 3H²/(8πG), but we need to verify the Friedmann equation
    # Friedmann equation: (ȧ/a)² = (8πG/3)ρ - kc²/a² + Λc²/3
    
    # For matter-dominated universe, ρ ∝ 1/a³
    # So current matter density ρ_m corresponds to scale factor a
    # The actual density at this scale factor is ρ = ρ_m
    
    # Calculate each term of the Friedmann equation
    term1 = (8 * math.pi * G / 3) * rho_m  # matter term
    term2 = -k * c**2 / a**2  # curvature term (will be 0 since k=0)
    term3 = Lambda * c**2 / 3  # cosmological constant term
    
    # Total H² from Friedmann equation
    H_squared = term1 + term2 + term3
    
    # Return the calculated H² value as verification
    result = H_squared
    return result
```",0.45
23,"Please calculate the critical density of the universe, given:
- Hubble parameter H = 1.832e-18 s⁻¹
 (equivalent to 0.86×the Planck measured value 65.39501889466081 km/s/Mpc)",Critical density of the universe ρ_c = 6.001e-27 kg/m³,"```python
def execute_code():
    # Given constants
    H = 1.832e-18  # Hubble parameter in s⁻¹
    
    # Gravitational constant in SI units (m³ kg⁻¹ s⁻²)
    G = 6.67430e-11
    
    # Critical density formula: ρ_c = 3H²/(8πG)
    import math
    rho_c = (3 * H**2) / (8 * math.pi * G)
    
    # Return the critical density in kg/m³
    return rho_c
```",0.45
24,"Calculate the age of the Universe given:
- Matter density parameter Ω_m = 0.216
- Dark energy density parameter Ω_Λ = 0.784
- Hubble constant H₀ = 67.8 km/s/Mpc",Age of the Universe t₀ = 15.22 Gyr,"```python
import numpy as np
from scipy.integrate import quad

def execute_code():
    # Given parameters
    Omega_m = 0.216
    Omega_Lambda = 0.784
    H0 = 67.8  # km/s/Mpc
    
    # Convert H0 to inverse seconds
    # 1 Mpc = 3.08567758128e19 km
    # So H0 in s^-1 = H0 / (3.08567758128e19) s^-1
    H0_s_inv = H0 / (3.08567758128e19)
    
    # The age of the universe is given by the integral:
    # t = ∫[0 to ∞] dz / [(1+z) * H(z)]
    # where H(z) = H0 * sqrt(Omega_m*(1+z)^3 + Omega_Lambda)
    # This can be rewritten as:
    # t = (1/H0) * ∫[0 to ∞] dz / [(1+z) * sqrt(Omega_m*(1+z)^3 + Omega_Lambda)]
    
    # Alternatively, we can use the scale factor a = 1/(1+z), so when z=0, a=1 and when z=∞, a=0
    # Then dt = da / (a * H(a)) where H(a) = H0 * sqrt(Omega_m/a^3 + Omega_Lambda)
    # So t = (1/H0) * ∫[0 to 1] da / sqrt(Omega_m/a + Omega_Lambda*a^2)
    
    def integrand_a(a):
        return 1.0 / np.sqrt(Omega_m / a + Omega_Lambda * a**2)
    
    # Perform the integration from 0 to 1
    integral_result, _ = quad(integrand_a, 0, 1, limit=1000)
    
    # Age in seconds
    age_seconds = integral_result / H0_s_inv
    
    # Convert to years (1 year = 3.154e7 seconds)
    age_years = age_seconds / (3.154e7)
    
    # Convert to billions of years
    age_gyr = age_years / 1e9
    
    return age_gyr
```",0.45
25,"Please calculate the angular diameter distance of the object, given:
- Physical diameter d = 527.40 pc
- Angular diameter θ = 19.88 arcsec","Angular diameter distance D_A = 1.689e+23 m
 (5472624.49 pc or 5.47 Mpc)","```python
def execute_code():
    # Given values
    d = 527.40  # physical diameter in parsecs (pc)
    theta = 19.88  # angular diameter in arcseconds
    
    # Convert angular diameter from arcseconds to radians
    # 1 arcsecond = (1/3600) degrees, and 1 degree = pi/180 radians
    theta_radians = theta / 3600 * (3.141592653589793 / 180)
    
    # Angular diameter distance formula: D_A = d / theta (when theta is in radians)
    # This gives the distance in the same units as d (parsecs)
    D_A = d / theta_radians
    
    return D_A
```",0.45
26,"Use the luminosity distance formula to calculate the distance, where:
- Luminosity of the object L = 2.674e+32 W
- Observed flux F = 3.120e-11 W/m²","Luminosity distance D_L = 8.259e+20 m
 (26761.71 pc or 0.03 Mpc)","```python
def execute_code():
    import math
    
    # Given values
    L = 2.674e+32  # Luminosity in watts
    F = 3.120e-11  # Observed flux in W/m²
    
    # Luminosity distance formula: F = L / (4 * π * d²)
    # Rearranging for distance: d = sqrt(L / (4 * π * F))
    
    d = math.sqrt(L / (4 * math.pi * F))
    
    return d
```",0.51
27,"Use the cosmological redshift formula to calculate the ratio of scale factors, given:
- Observed redshift z = 7.137
- Present-day scale factor a(t₀) = 1.0",Scale factor at emission a(tₑ) = 0.12290,"```python
def execute_code():
    # Given values
    z = 7.137
    a_present = 1.0
    
    # Cosmological redshift formula: 1 + z = a(t₀) / a(t)
    # Therefore, a(t) / a(t₀) = 1 / (1 + z)
    # Since a(t₀) = 1.0, the ratio of scale factors a(t)/a(t₀) = 1 / (1 + z)
    
    scale_factor_ratio = 1.0 / (1.0 + z)
    
    return scale_factor_ratio
```",0.45
28,"Please compute the cosmological power spectrum P(k), where:
- Dimensionless Hubble parameter h = 0.747
- Wavenumber k = 0.7773 h/Mpc
- Characteristic scale k_scale = 0.1 h/Mpc
- Density fluctuation amplitude Δ = 1.000
- Spectral index n_s = 0.959",Power spectrum P(k) = 7.1462e+00 (h⁻¹Mpc)³,"```python
def execute_code():
    # Given parameters
    h = 0.747
    k = 0.7773  # in units of h/Mpc
    k_scale = 0.1  # in units of h/Mpc
    Delta = 1.000
    n_s = 0.959
    
    # The cosmological power spectrum P(k) is given by:
    # P(k) = Δ² * (k / k_scale)^(n_s - 1)
    # Note: Since both k and k_scale are in the same units (h/Mpc), 
    # the ratio k/k_scale is dimensionless
    
    P_k = Delta**2 * (k / k_scale)**(n_s - 1)
    
    return P_k
```",0.45
29,"Use the parallax method to calculate the distance to a star, where:
- Parallax angle p = 0.364183 arcsec","Stellar distance d = 2.746 pc
 (or 8.473e+16 m)","```python
def execute_code():
    # Given parallax angle in arcseconds
    p = 0.364183
    
    # Distance in parsecs is given by d = 1/p where p is in arcseconds
    distance_parsecs = 1 / p
    
    # Return the distance in parsecs
    return distance_parsecs
```",0.45
30,"Using the distance modulus formula, calculate the difference between apparent magnitude and absolute magnitude, where the distance is $d=58520.08\,\text{pc}$ ($190866.75\,\text{ly}$).",The distance modulus is $m - M = 18.83652$.,"```python
def execute_code():
    # Given distance in parsecs
    d = 58520.08  # pc
    
    # Distance modulus formula: m - M = 5 * log10(d) - 5
    import math
    difference = 5 * math.log10(d) - 5
    
    return difference
```",0.45
31,"Use the period–luminosity relation to calculate the absolute magnitude, where the period is $P=45.56\,\text{days}$, the coefficients are $a=-3.53$ and $b=-2.81$.",The absolute magnitude is $M = -8.66487$,"```python
def execute_code():
    # Given values
    P = 45.56  # period in days
    a = -3.53
    b = -2.81
    
    # Period-luminosity relation: M = a * log10(P) + b
    import math
    M = a * math.log10(P) + b
    
    # final result return
    return M
```",0.45
32,"Use the Tully–Fisher relation to calculate the galaxy luminosity, where the rotation velocity is $V_{rot}=132.7\,\text{km/s}$ and the power-law index $\alpha=3.5$","The galaxy luminosity is $L = 2.37700e+09\,L_{\odot}$","```python
def execute_code():
    # Given values
    V_rot = 132.7  # rotation velocity in km/s
    alpha = 3.5    # power-law index
    
    # The Tully-Fisher relation states that L ∝ V_rot^alpha
    # Since we are not given a normalization constant, we'll compute the 
    # luminosity in arbitrary units proportional to V_rot^alpha
    L = V_rot ** alpha
    
    return L
```",0.45
33,"Calculate the weighted mean luminosity of a system of sources, given:
Source counts $n_i = [3, 1, 1, 2, 8]$
Luminosities of each source type $L_i = [9.386e+29, 7.604e+29, 6.829e+29, 1.156e+29, 1.033e+28] \,\mathrm{W}$","The weighted mean luminosity is $\bar{L} = 8.124e+29 \,\mathrm{W}$","```python
def execute_code():
    # Given data
    n_i = [3, 1, 1, 2, 8]
    L_i = [9.386e+29, 7.604e+29, 6.829e+29, 1.156e+29, 1.033e+28]
    
    # Calculate total number of sources
    total_n = sum(n_i)
    
    # Calculate weighted mean luminosity
    weighted_sum = sum(n * L for n, L in zip(n_i, L_i))
    weighted_mean_luminosity = weighted_sum / total_n
    
    return weighted_mean_luminosity
```",0.45
34,"Using the TRGB absolute magnitude formula, calculate the I-band absolute magnitude, given the color index $(V-I)_0 = 2.37$",The TRGB absolute magnitude is $M_I^{TRGB} = -3.88$,"```python
def execute_code():
    # Given color index (V-I)_0
    vi_color = 2.37
    
    # TRGB absolute magnitude formula in I-band
    # According to standard astronomical references, the TRGB I-band absolute magnitude
    # can be calculated using the formula:
    # M_I = -4.06 + 0.23 * ((V-I)_0 - 1.6)
    # This is a commonly used calibration from Lee et al. (1993) or similar sources
    
    M_I = -4.06 + 0.23 * (vi_color - 1.6)
    
    result = M_I
    return result
```",0.45
35,"Please use the Rayleigh criterion to calculate the angular resolution, where the wavelength is $\lambda=8.147e-07$ meters and the aperture diameter is $D=0.77$ meters.","The angular resolution is $\theta = 0.27\,\text{arcsec}$","```python
def execute_code():
    # Given values
    wavelength = 8.147e-07  # meters
    aperture_diameter = 0.77  # meters
    
    # Rayleigh criterion formula: theta = 1.22 * lambda / D
    # where theta is in radians
    angular_resolution = 1.22 * wavelength / aperture_diameter
    
    # Return the result in radians
    return angular_resolution
```",0.45
36,"Please calculate the signal-to-noise ratio (SNR) of an astronomical image with the following parameters:
Number of signal electrons $N_{\text{signal}}=6.34e+05$
Number of background electrons $N_{\text{background}}=7.80e+03$
Number of dark-current electrons $N_{\text{dark}}=6.23e+02$
Readout noise $\sigma_{\text{read}}=8.5$",The signal-to-noise ratio is $\text{SNR} = 790.82$,"```python
def execute_code():
    # Given parameters
    N_signal = 6.34e+05
    N_background = 7.80e+03
    N_dark = 6.23e+02
    sigma_read = 8.5
    
    # Calculate SNR using the formula:
    # SNR = N_signal / sqrt(N_signal + N_background + N_dark + sigma_read^2)
    snr = N_signal / ((N_signal + N_background + N_dark + sigma_read**2) ** 0.5)
    
    return snr
```",0.45
37,"Solve the radiative transfer equation with the following parameters:
Absorption coefficient $\alpha_\nu=1.724e-22\,\mathrm{m^{-1}}$
Emission coefficient $j_\nu=6.245e-15\,\mathrm{W\,m^{-3}\,sr^{-1}\,Hz^{-1}}$
Initial specific intensity $I_\nu=8.256e-07\,\mathrm{W\,m^{-2}\,sr^{-1}\,Hz^{-1}}$
Path element $ds=4.969e+17\,\mathrm{m}$","The rate of change of specific intensity is $\frac{dI_\nu}{ds} = 6.245e-15\,\mathrm{W\,m^{-3}\,sr^{-1}\,Hz^{-1}}$","```python
def execute_code():
    # Given parameters
    alpha_nu = 1.724e-22  # m^-1
    j_nu = 6.245e-15      # W m^-3 sr^-1 Hz^-1
    I_nu_initial = 8.256e-07  # W m^-2 sr^-1 Hz^-1
    ds = 4.969e+17        # m
    
    # Solve the radiative transfer equation:
    # dI_nu/ds = -alpha_nu * I_nu + j_nu
    # For a small path element ds, we can use the formal solution:
    # I_nu_final = I_nu_initial * exp(-alpha_nu * ds) + (j_nu / alpha_nu) * (1 - exp(-alpha_nu * ds))
    
    import math
    
    tau = alpha_nu * ds  # optical depth
    exp_term = math.exp(-tau)
    
    I_nu_final = I_nu_initial * exp_term + (j_nu / alpha_nu) * (1 - exp_term)
    
    return I_nu_final
```",0.45
38,"Calculate the relativistic Doppler effect, where:
- Emitted frequency $\nu=9.596e+16$ Hz
- Relative velocity $v=0.442c$ (approaching)","Observed frequency $\nu'=1.544e+17$Hz
 Relative change $\frac{\Delta\nu}{\nu}=+0.608$","```python
def execute_code():
    # Given values
    nu_emitted = 9.596e+16  # Hz
    v_ratio = 0.442  # v as a fraction of c (approaching)
    c = 3e8  # speed of light in m/s (not needed explicitly since we use ratio)
    
    # For approaching source, relativistic Doppler effect formula:
    # nu_observed = nu_emitted * sqrt((1 + beta) / (1 - beta))
    # where beta = v/c
    beta = v_ratio
    
    import math
    nu_observed = nu_emitted * math.sqrt((1 + beta) / (1 - beta))
    
    return nu_observed
```",0.45
39,"Calculate the synchrotron radiation power of an electron given:
- Magnetic field strength $B=9.924e-04$ T
- Lorentz factor $\gamma=6.057e+06$
- Pitch angle $\alpha=41.5^\circ$",Synchrotron radiation power $P=3.116e-34$ W,"```python
import math

def execute_code():
    # Given parameters
    B = 9.924e-04  # Magnetic field strength in Tesla
    gamma = 6.057e+06  # Lorentz factor
    alpha_deg = 41.5  # Pitch angle in degrees
    
    # Constants
    e = 1.602176634e-19  # elementary charge in Coulombs
    c = 299792458  # speed of light in m/s
    epsilon_0 = 8.8541878128e-12  # vacuum permittivity in F/m
    
    # Convert pitch angle to radians
    alpha_rad = math.radians(alpha_deg)
    
    # Calculate synchrotron radiation power using the formula:
    # P = (e^2 * c) / (6 * pi * epsilon_0) * (gamma^2 * (B^2 / B_c^2)) * sin^2(alpha)
    # where B_c = m_e^2 * c^3 / (e * hbar) is the critical magnetic field
    # However, a more direct formula is:
    # P = (2 * e^2 * c) / (3 * epsilon_0) * (gamma^2 * beta_perp^2) * (B^2 / B_q^2)
    # But the standard formula for synchrotron power is:
    # P = (sigma_T * c * U_B * gamma^2 * beta^2 * sin^2(alpha))
    # where sigma_T is Thomson cross section and U_B is magnetic energy density
    
    # Using the fundamental formula:
    # P = (e^2 * c) / (6 * pi * epsilon_0) * gamma^2 * (e^2 * B^2 * sin^2(alpha)) / (m_e^2 * c^2)
    # Simplified standard formula: P = (2/3) * (e^4 * B^2 * gamma^2 * sin^2(alpha)) / (4 * pi * epsilon_0^2 * m_e^2 * c^3)
    
    # Most commonly used formula:
    # P = (sigma_T * c * U_B * gamma^2 * beta^2 * sin^2(alpha))
    # where U_B = B^2 / (2 * mu_0) and sigma_T = (8 * pi / 3) * (e^4 / (4 * pi * epsilon_0)^2 * m_e^2 * c^4)
    
    # Let's use the direct formula:
    # P = (2 * e^4 * B^2 * gamma^2 * sin^2(alpha)) / (3 * (4 * pi * epsilon_0)^2 * m_e^2 * c^3)
    
    m_e = 9.1093837015e-31  # electron mass in kg
    mu_0 = 4 * math.pi * 1e-7  # vacuum permeability
    
    # Calculate sin^2(alpha)
    sin2_alpha = math.sin(alpha_rad) ** 2
    
    # Using the formula: P = (sigma_T * c * U_B * gamma^2 * sin^2(alpha)) 
    # since beta ≈ 1 for ultra-relativistic electrons
    sigma_T = 6.6524587321e-29  # Thomson cross section in m^2
    U_B = B**2 / (2 * mu_0)  # magnetic energy density
    
    P = sigma_T * c * U_B * gamma**2 * sin2_alpha
    
    return P
```",0.51
40,"Calculate the inverse Compton scattered photon energy, where:
- Electron Lorentz factor $\gamma=7.023e+05$
- Initial photon energy $E_{\text{initial}}=283.579$ eV",Scattered photon energy $E_{\text{scattered}}=139876051903910.109$ eV,"```python
def execute_code():
    # Given values
    gamma = 7.023e+05
    E_initial = 283.579  # in eV
    
    # Inverse Compton scattering - the scattered photon energy can be approximated as:
    # E_scattered ≈ (4/3) * gamma^2 * E_initial (in the Thomson regime for head-on collision)
    # This is the standard approximation for the average energy of inverse Compton scattered photons
    
    E_scattered = (4/3) * gamma**2 * E_initial
    
    return E_scattered
```",0.45
41,"Calculate the maximum detection distance of an astronomical object, where:
- Luminosity of the object $L=213394.277 L_{\odot}$
- Minimum detectable flux $F_{\min}=5.443e-21$ W/m²","Maximum detection distance $D_{\max}=1119792523.094$ pc
 (or 3.456e+25 m)","```python
def execute_code():
    # Given values
    L = 213394.277  # in solar luminosities
    F_min = 5.443e-21  # in W/m^2
    
    # Solar luminosity in watts
    L_sun = 3.828e26  # W
    
    # Convert object luminosity to watts
    L_watts = L * L_sun
    
    # Calculate maximum detection distance using the formula: d = sqrt(L / (4 * pi * F))
    import math
    d = math.sqrt(L_watts / (4 * math.pi * F_min))
    
    # Return the result in meters
    return d
```",0.51
42,"Calculate the Gaussian spectral line intensity with:
- Line center intensity $I_0=4.061e-19$ W/m²/Hz
- Central frequency $\nu_0=1.024e+10$ Hz
- Line width $\sigma=9.771e+07$ Hz
- Observed frequency $\nu=1.029e+10$ Hz",The intensity at observed frequency $\nu=1.029e+10$ Hz is $I(\nu)=3.550e-19$ W/m²/Hz,"```python
def execute_code():
    import math
    
    # Given parameters
    I0 = 4.061e-19  # W/m²/Hz
    nu0 = 1.024e+10  # Hz
    sigma = 9.771e+07  # Hz
    nu = 1.029e+10  # Hz
    
    # Gaussian spectral line intensity formula:
    # I(nu) = I0 * exp(-(nu - nu0)^2 / (2 * sigma^2))
    intensity = I0 * math.exp(-((nu - nu0) ** 2) / (2 * sigma ** 2))
    
    return intensity
```",0.45
43,"Calculate the exponentially attenuated intensity, given:
- Initial intensity $I_0=543.724$ W/m²
- Medium type: Lead glass ($\alpha=1.000e+02$ m⁻¹)
- Propagation distance $x=6.463$ m",Attenuated intensity $I = 0.000$ W/m²,"```python
def execute_code():
    # Given values
    I0 = 543.724  # Initial intensity in W/m²
    alpha = 1.000e+02  # Attenuation coefficient in m⁻¹
    x = 6.463  # Propagation distance in meters
    
    # Calculate exponentially attenuated intensity using Beer-Lambert law
    # I = I0 * exp(-alpha * x)
    import math
    I = I0 * math.exp(-alpha * x)
    
    return I
```",0.45
44,"Calculate the Jeans mass given:
- Temperature $T=880.6$ K
- Mass density $\rho=5.662e-19$ kg/m³
- Mean molecular weight $\mu=1.53$",Jeans mass $M_J=69071.126$ solar masses,"```python
def execute_code():
    import math
    
    # Given values
    T = 880.6  # Temperature in Kelvin
    rho = 5.662e-19  # Mass density in kg/m^3
    mu = 1.53  # Mean molecular weight
    
    # Physical constants
    k_B = 1.380649e-23  # Boltzmann constant in J/K
    G = 6.67430e-11  # Gravitational constant in m^3/(kg*s^2)
    m_H = 1.67262192369e-27  # Mass of hydrogen atom in kg
    
    # Jeans mass formula:
    # M_J = (pi^(5/2) / 6) * (k_B * T / (G * mu * m_H))^(3/2) * (1 / sqrt(rho))
    
    # Calculate the Jeans mass
    numerator = (math.pi ** (5/2)) / 6
    thermal_term = (k_B * T) / (G * mu * m_H)
    jeans_mass = numerator * (thermal_term ** (3/2)) * (1 / math.sqrt(rho))
    
    return jeans_mass
```",0.45
45,"Calculate the free-fall time, where:
- Drop height $h=696.819$ m
- Gravitational environment: Earth ($g=9.807$ m/s²)",Free-fall time $t = 11.921$ s,"```python
def execute_code():
    # Given values
    h = 696.819  # drop height in meters
    g = 9.807    # gravitational acceleration in m/s^2
    
    # Free-fall time formula: t = sqrt(2h/g)
    t = (2 * h / g) ** 0.5
    
    return t
```",0.45
46,"Use the Saha equation to calculate the number density ratio of ionization stages, where:
- Temperature $T=24004.9$ K
- Ionization energy $\chi_i=7.62$ eV
- Partition functions $Z_i=4$, $Z_{i+1}=2$
- Electron number density $n_e=5.421e+19$ m$^{-3}$",Number density ratio $\frac{n_{i+1}}{n_i} = 4.161e+06$,"```python
def execute_code():
    import math
    
    # Given parameters
    T = 24004.9  # Temperature in Kelvin
    chi_i = 7.62  # Ionization energy in eV
    Z_i = 4      # Partition function for stage i
    Z_i_plus_1 = 2  # Partition function for stage i+1
    n_e = 5.421e19  # Electron number density in m^-3
    
    # Physical constants
    k_B = 1.380649e-23  # Boltzmann constant in J/K
    eV_to_J = 1.602176634e-19  # Conversion factor from eV to Joules
    h = 6.62607015e-34  # Planck constant in J·s
    pi = math.pi
    m_e = 9.1093837015e-31  # Electron mass in kg
    
    # Convert ionization energy to Joules
    chi_i_J = chi_i * eV_to_J
    
    # Calculate the thermal de Broglie wavelength term
    # The Saha equation has the form:
    # n_{i+1} * n_e / n_i = (2 * pi * m_e * k_B * T / h^2)^(3/2) * (2 * Z_{i+1} / Z_i) * exp(-chi_i / (k_B * T))
    
    # Calculate the coefficient term
    coeff = (2 * pi * m_e * k_B * T) / (h**2)
    coeff_power = coeff**(3/2)
    
    # Calculate the exponential term
    exp_term = math.exp(-chi_i_J / (k_B * T))
    
    # Calculate the right-hand side of the Saha equation
    rhs = coeff_power * (2 * Z_i_plus_1 / Z_i) * exp_term
    
    # The number density ratio we want is n_{i+1} / n_i
    # From the Saha equation: n_{i+1} / n_i = rhs / n_e
    ratio = rhs / n_e
    
    return ratio
```",0.51
47,"Calculate the 21 cm hydrogen line radiation intensity, where:
- Neutral hydrogen column density $N_{\text{HI}}=9.183e+21$ m$^{-2}$
- Kinetic temperature $T_k=3581.3$ K
- Line width $\Delta\nu=1.884e+05$ Hz",21 cm line radiation intensity $I = 0.000$ mK,"```python
def execute_code():
    # Given parameters
    N_HI = 9.183e+21  # m^-2
    T_k = 3581.3      # K
    delta_nu = 1.884e+05  # Hz
    
    # Physical constants
    c = 299792458     # speed of light in m/s
    k_B = 1.380649e-23  # Boltzmann constant in J/K
    h = 6.62607015e-34  # Planck constant in J*s
    nu_0 = 1420405751.7667  # rest frequency of 21 cm line in Hz
    
    # Calculate the optical depth tau
    # For the 21 cm line, the optical depth is given by:
    # tau = (c^2 / (8*pi*nu_0^2)) * (g_u/g_l - 1) * (A_ul * N_HI) / (delta_nu)
    # For hydrogen 21 cm transition:
    # g_u/g_l = 3 (statistical weights ratio)
    # A_ul = 2.86888e-15 s^-1 (Einstein A coefficient for spontaneous emission)
    
    A_ul = 2.86888e-15  # s^-1
    g_ratio = 3.0
    
    # Optical depth calculation
    tau = (c**2 / (8 * 3.141592653589793 * nu_0**2)) * (g_ratio - 1) * (A_ul * N_HI) / delta_nu
    
    # Brightness temperature calculation
    # T_b = T_k * (1 - exp(-tau))
    import math
    T_b = T_k * (1 - math.exp(-tau))
    
    # Convert brightness temperature to intensity using Rayleigh-Jeans approximation
    # I = (2 * k_B * nu_0^2 / c^2) * T_b
    I = (2 * k_B * nu_0**2 / c**2) * T_b
    
    return I
```",0.45
48,"Calculate the extinction at wavelength $\lambda=1.830e-07$ m, where:
- Mass absorption coefficient $\kappa_\lambda=2.882e-03$ m²/kg
- Medium density $\rho=8.462e-20$ kg/m³
- Propagation path $L=32.471$ pc",The extinction at wavelength $\lambda=1.830e-07$ m is $A_\lambda = 0.000$,"```python
def execute_code():
    # Given values
    kappa_lambda = 2.882e-03  # m²/kg
    rho = 8.462e-20  # kg/m³
    L_pc = 32.471  # pc
    
    # Convert parsecs to meters (1 pc = 3.08567758128e16 m)
    pc_to_m = 3.08567758128e16
    L_m = L_pc * pc_to_m
    
    # Calculate optical depth tau = kappa * rho * L
    tau = kappa_lambda * rho * L_m
    
    # Extinction A_lambda is typically related to optical depth by A_lambda = (2.5 / ln(10)) * tau
    # However, in many contexts, especially when not specified otherwise, extinction can refer directly to optical depth
    # But the standard astronomical definition of extinction magnitude is A = 2.5 * log10(exp(tau)) = (2.5/ln(10)) * tau
    import math
    A_lambda = (2.5 / math.log(10)) * tau
    
    return A_lambda
```",0.39
49,"Calculate the molecular cooling rate, where:
- H2 number density $n(\text{H}_2)=6.407e+10$ m$^{-3}$
- Molecular X number density $n(X)=4.016e+09$ m$^{-3}$
- Temperature $T=402.9$ K
- Molecular level parameters: CO J=1-0, 2-1, 3-2",Molecular cooling rate $\Lambda = 3.390e-08$ W/m$^3$,"```python
def execute_code():
    # Given parameters
    n_H2 = 6.407e+10  # m^-3
    n_X = 4.016e+09   # m^-3
    T = 402.9         # K
    
    # For CO rotational transitions, we need Einstein A coefficients and energy levels
    # CO J=1-0: A_10 = 7.4e-8 s^-1, E_1/k = 5.53 K
    # CO J=2-1: A_21 = 6.9e-7 s^-1, E_2/k = 16.6 K  
    # CO J=3-2: A_32 = 2.5e-6 s^-1, E_3/k = 33.2 K
    # k_B = Boltzmann constant = 1.380649e-23 J/K
    
    import math
    
    # Constants
    k_B = 1.380649e-23  # J/K
    
    # Transition parameters [A_ul, E_u/k (in K)]
    transitions = [
        [7.4e-8, 5.53],   # J=1-0
        [6.9e-7, 16.6],   # J=2-1  
        [2.5e-6, 33.2]    # J=3-2
    ]
    
    # Calculate cooling rate for each transition
    # Lambda = n(X) * h * nu_ul * A_ul * (n_u/n_total) * exp(-E_u/kT) / (1 - exp(-h*nu_ul/kT))
    # For simplicity, assuming optically thin case and using the standard formula:
    # Cooling rate per transition = n(H2) * n(X) * gamma_ul
    # where gamma_ul = (h * c / lambda_ul) * k_12 * exp(-E_u/kT)
    # However, a more direct approach for molecular cooling rate is:
    # Lambda = sum over transitions of [n(X) * h * nu_ul * A_ul * N_u]
    # But we need the level populations. Assuming LTE:
    # N_u/N = g_u * exp(-E_u/kT) / Z, where Z is partition function
    
    # For CO, statistical weights g_J = 2J + 1
    # J levels: 1, 2, 3 (upper levels for the given transitions)
    g_factors = [3, 5, 7]  # 2*1+1, 2*2+1, 2*3+1
    
    # Frequencies for CO transitions (in Hz)
    # J=1-0: 115.27 GHz, J=2-1: 230.54 GHz, J=3-2: 345.80 GHz
    frequencies = [115.27e9, 230.54e9, 345.80e9]
    
    # Planck's constant
    h = 6.62607015e-34  # J*s
    
    # Calculate partition function Z (approximate, considering only relevant levels)
    # Z = sum(g_J * exp(-E_J/kT))
    # E_J/k values in Kelvin: J=0: 0, J=1: 5.53, J=2: 16.6, J=3: 33.2
    E_over_k = [0, 5.53, 16.6, 33.2]
    g_all = [1, 3, 5, 7]  # J=0,1,2,3
    Z = sum(g_all[i] * math.exp(-E_over_k[i] / T) for i in range(4))
    
    total_cooling_rate = 0.0
    
    for i, (A_ul, E_u_over_k) in enumerate(transitions):
        # Upper level is J = i+1
        J_upper = i + 1
        g_u = g_factors[i]
        
        # Energy of upper level
        E_u = E_u_over_k * k_B
        
        # Frequency of transition
        nu = frequencies[i]
        
        # Energy of photon
        h_nu = h * nu
        
        # Level population fraction in LTE
        N_u_frac = g_u * math.exp(-E_u_over_k / T) / Z
        
        # Cooling rate contribution from this transition
        # Lambda = n(X) * h_nu * A_ul * N_u_frac * (accounting for spontaneous emission)
        # Since N_u = n(X) * N_u_frac, and each de-excitation releases h_nu energy
        cooling_contribution = n_X * h_nu * A_ul * N_u_frac
        
        total_cooling_rate += cooling_contribution
    
    result = total_cooling_rate
    return result
```",0.45
50,"Use the Saha-Boltzmann equation to calculate the ionization balance, where:
- Temperature $T=5791.8$ K
- Ionization energy $\chi_i=14.61$ eV
- Degeneracies $g_i=4$, $g_{i+1}=2$
- Electron number density $n_e=9.564e+19$ m$^{-3}$",Ionization balance ratio $\frac{n_{i+1}}{n_i} = 2.162e-06$,"```python
def execute_code():
    import math
    
    # Given parameters
    T = 5791.8  # Temperature in Kelvin
    chi_i = 14.61  # Ionization energy in eV
    g_i = 4  # Degeneracy of ionized state
    g_i_plus_1 = 2  # Degeneracy of next ionization state
    n_e = 9.564e+19  # Electron number density in m^-3
    
    # Physical constants
    k_B = 8.617333262145e-5  # Boltzmann constant in eV/K
    h = 6.62607015e-34  # Planck constant in J·s
    m_e = 9.1093837015e-31  # Electron mass in kg
    k_B_SI = 1.380649e-23  # Boltzmann constant in J/K
    eV_to_J = 1.602176634e-19  # Conversion factor from eV to Joules
    
    # Convert ionization energy to Joules for the thermal de Broglie wavelength calculation
    chi_i_J = chi_i * eV_to_J
    
    # Calculate the thermal de Broglie wavelength term
    # lambda_th^3 = (h^2 / (2*pi*m_e*k_B*T))^(3/2)
    lambda_th_cubed = (h**2 / (2 * math.pi * m_e * k_B_SI * T))**(3/2)
    
    # Calculate the exponential term
    exp_term = math.exp(-chi_i / (k_B * T))
    
    # Saha equation: n_{i+1}/n_i = (2/g_i) * (g_{i+1}/g_i) * (1/n_e) * (2*pi*m_e*k_B*T/h^2)^(3/2) * exp(-chi_i/(k_B*T))
    # But more commonly written as: n_{i+1}/n_i = (g_{i+1}/g_i) * (1/n_e) * (2*pi*m_e*k_B*T/h^2)^(3/2) * exp(-chi_i/(k_B*T))
    # Note: (2*pi*m_e*k_B*T/h^2)^(3/2) = 1/lambda_th^3
    
    ratio = (g_i_plus_1 / g_i) * (1 / n_e) * (1 / lambda_th_cubed) * exp_term
    
    # The ionization balance is typically expressed as the ratio of ionized to neutral atoms
    result = ratio
    
    return result
```",0.51
51,"In a three-body system, the three bodies have masses:
m₁ = 1.32e+25 kg, m₂ = 9.15e+25 kg, m₃ = 2.24e+25 kg.
At a certain instant, their positions in 2D space are:
r₁ = (509544860.59384584, -710222662.9016883) m, r₂ = (452064028.2080569, -699752537.5522759) m, r₃ = (-228846866.51914763, 820099963.0375674) m.
The gravitational constant is G = 6.67430×10⁻¹¹ N·m²/kg².
Using the Newtonian three-body equations of motion, compute the acceleration vector of body m₁ at this instant.","The acceleration of body m₁ is a₁ = (-1.7593127141773577, 0.3208843998160993) m/s²","```python
def execute_code():
    import numpy as np
    
    # Given constants
    G = 6.67430e-11  # gravitational constant in N·m²/kg²
    
    # Masses in kg
    m1 = 1.32e+25
    m2 = 9.15e+25
    m3 = 2.24e+25
    
    # Positions in meters
    r1 = np.array([509544860.59384584, -710222662.9016883])
    r2 = np.array([452064028.2080569, -699752537.5522759])
    r3 = np.array([-228846866.51914763, 820099963.0375674])
    
    # Calculate acceleration of body m1 due to gravitational forces from m2 and m3
    # Acceleration a1 = G * m2 * (r2 - r1) / |r2 - r1|^3 + G * m3 * (r3 - r1) / |r3 - r1|^3
    
    # Vector from r1 to r2
    r12 = r2 - r1
    # Distance between r1 and r2
    d12 = np.linalg.norm(r12)
    # Acceleration contribution from m2
    a12 = G * m2 * r12 / (d12 ** 3)
    
    # Vector from r1 to r3
    r13 = r3 - r1
    # Distance between r1 and r3
    d13 = np.linalg.norm(r13)
    # Acceleration contribution from m3
    a13 = G * m3 * r13 / (d13 ** 3)
    
    # Total acceleration of m1
    a1 = a12 + a13
    
    # Return as a list for JSON serialization
    result = a1.tolist()
    return result
```",0.51
52,"Given the fundamental equations of perturbation theory:
dr/dt = v, dv/dt = -μ/r³ · r + F_pert.
The position vector is r = (2.032205037451003, 8.201901659086458, 9.616577505893401), the velocity vector is v = (-3.0306055928648004, -4.515036146376569, -3.4491694774566337),
the gravitational parameter is μ = 83.736, and the perturbing acceleration is F_pert = (0.008694754353109494, 0.006813807352722056, 0.002172342324621329).
Please compute the acceleration dv/dt.","dv/dt = (-0.0724186727960485, -0.32055687643582637, -0.3816637099306732)","```python
def execute_code():
    import numpy as np
    
    # Given vectors and parameters
    r = np.array([2.032205037451003, 8.201901659086458, 9.616577505893401])
    v = np.array([-3.0306055928648004, -4.515036146376569, -3.4491694774566337])
    mu = 83.736
    F_pert = np.array([0.008694754353109494, 0.006813807352722056, 0.002172342324621329])
    
    # Calculate the magnitude of r
    r_magnitude = np.linalg.norm(r)
    
    # Calculate the gravitational acceleration term: -μ/r³ · r
    grav_accel = -mu / (r_magnitude ** 3) * r
    
    # Total acceleration dv/dt = gravitational acceleration + perturbing acceleration
    dv_dt = grav_accel + F_pert
    
    # Convert to list for JSON serialization
    result = dv_dt.tolist()
    
    return result
```",0.45
53,"Compute the Jacobi integral, where:
- Angular velocity $\Omega=8.817e-15$ rad/s
- Angular momentum $L_z=3.434e+12$ kg·m²/s
- Object velocity $v=41.94$ km/s
- Galaxy mass $M=807955073148.57×10^{10} M_{\odot}$
- Distance from center $r=58.01$ kpc",Jacobi integral $C = 1.180e+11$ m²/s²,"```python
def execute_code():
    import math
    
    # Given constants
    Omega = 8.817e-15  # rad/s
    Lz = 3.434e+12     # kg·m²/s
    v = 41.94e3        # m/s (converted from km/s)
    M_solar = 807955073148.57e10  # in solar masses
    r_kpc = 58.01      # kpc
    
    # Physical constants
    G = 6.67430e-11    # gravitational constant in m³/(kg·s²)
    solar_mass = 1.98847e30  # kg
    pc_to_m = 3.08567758128e16  # parsec to meters
    
    # Convert mass to kg
    M = M_solar * solar_mass
    
    # Convert distance to meters
    r = r_kpc * 1000 * pc_to_m  # kpc to meters
    
    # Calculate potential energy term: -G*M/r
    potential_energy = -G * M / r
    
    # Calculate kinetic energy term: 0.5 * v^2
    kinetic_energy = 0.5 * v**2
    
    # Calculate rotational term: -0.5 * Omega^2 * r^2
    rotational_term = -0.5 * Omega**2 * r**2
    
    # Calculate angular momentum term: Omega * Lz
    angular_momentum_term = Omega * Lz
    
    # Jacobi integral: C_J = 2*U_eff - v^2 = 2*(potential_energy + rotational_term) - v^2 + 2*angular_momentum_term
    # But the standard form is: C_J = 2*Phi_eff - v^2, where Phi_eff = Phi - 0.5*Omega^2*r^2 + Omega*Lz/m
    # However, since we have Lz directly, and the standard Jacobi integral in rotating frame is:
    # C_J = v^2/2 - Phi + Omega*Lz - Omega^2*r^2/2
    # So C_J = kinetic_energy + (-potential_energy) + angular_momentum_term + rotational_term
    
    # Actually, the Jacobi integral is typically defined as:
    # C_J = 2*U - v^2, where U is the effective potential
    # U = -GM/r - Omega^2*r^2/2 + Omega*Lz/m
    # But since we don't have mass of the object, and Lz is given as absolute angular momentum,
    # we need to be careful.
    
    # Let's reconsider: In the context of galactic dynamics, the Jacobi integral for a test particle 
    # in a rotating frame is often written as:
    # E_J = 0.5*v^2 + Phi(r) - Omega*Lz
    # But sometimes it's defined as C_J = -2*E_J
    
    # Given the parameters, the most standard form would be:
    # C_J = v^2/2 - G*M/r - Omega^2*r^2/2 + Omega*Lz/m_object
    
    # Wait, but Lz = m_object * v_phi * r, so Omega*Lz = Omega*m_object*v_phi*r
    # This suggests that if we're working with specific energy (per unit mass), then we should use Lz/m_object
    
    # However, looking at the units: Lz is given in kg·m²/s, which is absolute angular momentum
    # To get specific angular momentum, we would need the mass of the object, which isn't provided
    
    # This suggests that perhaps the question expects us to use the form where the Jacobi integral 
    # is calculated as: C_J = v^2/2 - G*M/r - Omega^2*r^2/2 + Omega*Lz_specific
    # But without the object's mass, we can't compute Lz_specific
    
    # Let me check the units of the expected result. The Jacobi integral should have units of energy per unit mass (m²/s²)
    # Given that, and that Lz is in kg·m²/s, if we divide by an unknown mass, we can't proceed
    
    # Alternative interpretation: In some contexts, especially when dealing with the restricted three-body problem,
    # the Jacobi constant is defined as: C = 2*U - v^2, where U includes the gravitational potential and centrifugal potential
    
    # For galactic dynamics in a rotating frame, the effective potential is:
    # Phi_eff = -GM/r - (1/2)*Omega^2*r^2
    # And the Jacobi integral (energy in rotating frame) is: E_J = (1/2)*v^2 + Phi_eff - Omega*Lz_specific
    
    # But again, we need Lz_specific = Lz/m_object
    
    # Given that the problem provides Lz in absolute terms but doesn't provide the object's mass,
    # I suspect there might be an error in interpretation. However, looking at typical problems,
    # sometimes the Jacobi integral is expressed as:
    # C_J = v^2 - 2*GM/r - Omega^2*r^2 + 2*Omega*Lz_specific
    
    # Let's assume that the object's mass is 1 kg for calculation purposes, which would make Lz_specific = Lz
    # This is a common approach when dealing with test particles where the mass cancels out
    
    # So assuming m_object = 1 kg:
    Lz_specific = Lz  # m²/s (since m=1 kg)
    
    # Now calculate the Jacobi integral using the standard form for rotating frames:
    # C_J = v^2/2 - G*M/r - Omega^2*r^2/2 + Omega*Lz_specific
    
    CJ = kinetic_energy + (-G * M / r) - 0.5 * Omega**2 * r**2 + Omega * Lz_specific
    
    return CJ
```",0.45
54,"Please calculate the Schwarzschild radius for an object with mass $M=53.6\,M_{\odot}$","The Schwarzschild radius is $r_s = 1.583e+05\,\mathrm{m}$","```python
def execute_code():
    # Constants
    G = 6.67430e-11  # gravitational constant in m^3 kg^-1 s^-2
    c = 299792458    # speed of light in m/s
    M_sun = 1.98847e30  # solar mass in kg
    
    # Given mass
    M = 53.6 * M_sun  # mass in kg
    
    # Schwarzschild radius formula: r_s = 2GM/c^2
    r_s = 2 * G * M / (c ** 2)
    
    # Return the result in meters
    return r_s
```",0.45
55,"Calculate the curvature radiation power of a relativistic electron with the following parameters:
Curvature radius $\rho=3.220e+05\,\mathrm{m}$
Lorentz factor $\gamma=9.759e+08$","Curvature radiation power $P = 4.488e-05\,\mathrm{W}$","```python
def execute_code():
    import math
    
    # Given parameters
    rho = 3.220e+05  # curvature radius in meters
    gamma = 9.759e+08  # Lorentz factor
    
    # Physical constants
    c = 2.99792458e8  # speed of light in m/s
    e = 1.602176634e-19  # elementary charge in C
    epsilon_0 = 8.8541878128e-12  # vacuum permittivity in F/m
    
    # Calculate curvature radiation power using the formula:
    # P = (2 * e^2 * c) / (3 * 4 * pi * epsilon_0) * (gamma^4 / rho^2)
    # The constant term (2 * e^2 * c) / (3 * 4 * pi * epsilon_0) can be simplified
    
    constant_term = (2 * e**2 * c) / (3 * 4 * math.pi * epsilon_0)
    power = constant_term * (gamma**4) / (rho**2)
    
    return power
```",0.45
56,"Calculate the accretion disk temperature distribution with the following parameters:
Central mass $M=18.6\,M_{\odot}$
Accretion rate $\dot{M}=8.46e-08\,M_{\odot}/\mathrm{yr}$
Inner radius $r_{\mathrm{in}}=41.1\,\mathrm{km}$
Target radius $r=2467.0\,\mathrm{km}$","Temperature at radius $T(r) = 1125782.45\,\mathrm{K}$","```python
def execute_code():
    import math
    
    # Constants
    G = 6.67430e-8  # gravitational constant in cm^3 g^-1 s^-2
    sigma_sb = 5.670374419e-5  # Stefan-Boltzmann constant in erg cm^-2 s^-1 K^-4
    M_sun = 1.98847e33  # solar mass in grams
    yr_to_s = 3.154e7  # seconds in a year
    km_to_cm = 1e5  # kilometers to centimeters
    
    # Given parameters
    M = 18.6 * M_sun  # central mass in grams
    M_dot = 8.46e-08 * M_sun / yr_to_s  # accretion rate in g/s
    r_in = 41.1 * km_to_cm  # inner radius in cm
    r = 2467.0 * km_to_cm  # target radius in cm
    
    # Calculate the temperature using the standard thin disk formula
    # T(r) = [3GMṀ/(8πσr^3)]^(1/4) * [1 - (r_in/r)^(1/2)]^(1/4)
    
    prefactor = 3 * G * M * M_dot / (8 * math.pi * sigma_sb * r**3)
    geometric_factor = 1 - math.sqrt(r_in / r)
    
    # Ensure geometric factor is non-negative
    if geometric_factor < 0:
        geometric_factor = 0
    
    T = (prefactor * geometric_factor)**(1/4)
    
    return T
```",0.51
57,"Compute the remaining energy based on energy conservation. Given:
Initial energy $E_0 = 25.07\,\mathrm{eV}$
Energy change $E_2 = -4.11\,\mathrm{eV}$","The remaining energy is $E_1 = 29.19\,\mathrm{eV}$","```python
def execute_code():
    # Given values
    E0 = 25.07  # Initial energy in eV
    E2 = -4.11  # Energy change in eV
    
    # Compute remaining energy using energy conservation
    # Remaining energy = Initial energy + Energy change
    remaining_energy = E0 + E2
    
    return remaining_energy
```",0.45
58,"Calculate the free-free emission power spectrum with the following parameters:
Atomic number $Z=6$
Electron number density $n_e=4.077e+19\,\mathrm{m^{-3}}$
Ion number density $n_i=4.055e+19\,\mathrm{m^{-3}}$
Temperature $T=5.719e+07\,\mathrm{K}$
Frequency $\nu=1.963e+14\,\mathrm{Hz}$
Gaunt factor $g_{ff}=2.35$","The emission power spectrum is $P_\nu = 3.040e-14\,\mathrm{W\,m^{-3}\,Hz^{-1}}$","```python
def execute_code():
    import numpy as np
    
    # Given parameters
    Z = 6
    n_e = 4.077e+19  # m^-3
    n_i = 4.055e+19  # m^-3
    T = 5.719e+07    # K
    nu = 1.963e+14   # Hz
    g_ff = 2.35
    
    # Physical constants
    e = 1.602176634e-19  # elementary charge in C
    epsilon_0 = 8.8541878128e-12  # vacuum permittivity in F/m
    m_e = 9.1093837015e-31  # electron mass in kg
    k_B = 1.380649e-23  # Boltzmann constant in J/K
    c = 299792458  # speed of light in m/s
    
    # Calculate the free-free emission coefficient (power per unit volume per unit frequency)
    # Formula: P_ν = (64 * π^4 * e^6 * Z^2 * n_e * n_i) / (3 * sqrt(3) * c^3 * m_e^2 * epsilon_0^3 * h^3 * nu) * exp(-h*nu/(k_B*T)) * g_ff
    # However, a more standard form is:
    # j_ν = (8 * π * e^6 * Z^2 * n_e * n_i) / (3 * sqrt(3) * c^3 * m_e^2 * epsilon_0^3 * h * nu) * exp(-h*nu/(k_B*T)) * g_ff
    # But since we don't have Planck's constant explicitly needed in some formulations,
    # let's use the formula from Rybicki & Lightman (Eq. 5.14a):
    # j_ν = (π * e^6 * Z^2 * n_e * n_i) / (4 * ε_0^3 * c^3 * m_e^2 * ν^2) * (2π/(3*k_B*T*m_e))^(1/2) * g_ff * exp(-h*nu/(k_B*T))
    
    # Actually, let's use the standard formula for free-free emission coefficient:
    # j_ν = (64 * π^4 * e^6 * Z^2 * n_e * n_i) / (3 * sqrt(3) * c^3 * m_e^2 * epsilon_0^3 * h * nu) * exp(-h*nu/(k_B*T)) * g_ff
    # But we need Planck's constant
    h = 6.62607015e-34  # Planck's constant in J*s
    
    # Calculate the exponential factor
    exp_factor = np.exp(-h * nu / (k_B * T))
    
    # Calculate the prefactor
    numerator = 64 * (np.pi**4) * (e**6) * (Z**2) * n_e * n_i
    denominator = 3 * np.sqrt(3) * (c**3) * (m_e**2) * (epsilon_0**3) * h * nu
    
    j_nu = (numerator / denominator) * exp_factor * g_ff
    
    result = j_nu
    return result
```",0.45
59,"Calculate the Pauli repulsive force with the following parameters:
Force constant $k=2.158e-08\,\mathrm{N}$
Decay coefficient $\alpha=8.031e+10\,\mathrm{m^{-1}}$
Distance $r=5.280e-11\,\mathrm{m}$","The Pauli repulsive force is $F_{\text{Pauli}} = -3.109e-10\,\mathrm{N}$","```python
def execute_code():
    # Given parameters
    k = 2.158e-08  # N
    alpha = 8.031e+10  # m^-1
    r = 5.280e-11  # m
    
    # Pauli repulsive force formula: F = k * alpha * exp(-alpha * r)
    import math
    force = k * alpha * math.exp(-alpha * r)
    
    return force
```",0.45
60,"Calculate the Einstein radius of a gravitational lens with the following parameters:
Lens mass $M=2.34e+11\,M_{\odot}$
Lens distance $D_L=1738.7\,\mathrm{Mpc}$
Source distance $D_S=2097.1\,\mathrm{Mpc}$","The Einstein radius is $\theta_E = 0.43\,\mathrm{arcsec}$","```python
def execute_code():
    import math
    
    # Constants
    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2
    c = 299792458    # Speed of light in m/s
    M_sun = 1.98847e30  # Solar mass in kg
    pc = 3.085677581e16  # Parsec in meters
    
    # Given parameters
    M = 2.34e11 * M_sun  # Lens mass in kg
    D_L = 1738.7e6 * pc  # Lens distance in meters
    D_S = 2097.1e6 * pc  # Source distance in meters
    
    # Calculate D_LS (distance between lens and source)
    D_LS = D_S - D_L
    
    # Calculate Einstein radius in radians
    theta_E = math.sqrt((4 * G * M / c**2) * (D_LS / (D_L * D_S)))
    
    # Convert to arcseconds (1 radian = 206265 arcseconds)
    theta_E_arcsec = theta_E * 206265
    
    return theta_E_arcsec
```",0.51
61,"Compute the particle flux with the following parameters:
Particle number density $n=9.481e+19\,\mathrm{m^{-3}}$
Particle velocity $v=2.884e+05\,\mathrm{m\,s^{-1}}$","The particle flux is $F = 2.734e+25\,\mathrm{m^{-2}\,s^{-1}}$","```python
def execute_code():
    # Given parameters
    n = 9.481e+19  # particle number density in m^-3
    v = 2.884e+05  # particle velocity in m/s
    
    # Particle flux formula: Φ = n * v
    particle_flux = n * v
    
    return particle_flux
```",0.39
62,"Calculate the stellar oscillation frequency with the following parameters:
Large frequency separation $\Delta\nu=287.74\,\mu\mathrm{Hz}$
Phase offset $\epsilon=1.41$
Angular degree $l=2$
Radial order $n=24$
Offset term $d_{02}=4.41\,\mu\mathrm{Hz}$","The oscillation frequency is $\nu_{24,2} = 7595.07\,\mu\mathrm{Hz}$","```python
def execute_code():
    # Given parameters
    Delta_nu = 287.74  # in microHz
    epsilon = 1.41
    l = 2
    n = 24
    d_02 = 4.41  # in microHz
    
    # For l=2 modes, the frequency is given by:
    # nu_{n,l} = (n + l/2 + epsilon) * Delta_nu - d_{0l}/2
    # For l=2, d_{02} is given, so we use d_{0l} = d_{02}
    
    nu = (n + l/2 + epsilon) * Delta_nu - d_02 / 2
    
    return nu
```",0.45
63,"Calculate the radiation intensity with the following parameters:
Source luminosity $L=6.975e+31\,\mathrm{W}$
Observation distance $r=2.667e+21\,\mathrm{m}$","The radiation intensity is $I = 7.802e-13\,\mathrm{W\,m^{-2}}$","```python
def execute_code():
    # Given parameters
    L = 6.975e+31  # Source luminosity in watts (W)
    r = 2.667e+21  # Observation distance in meters (m)
    
    # Radiation intensity formula: I = L / (4 * pi * r^2)
    import math
    I = L / (4 * math.pi * r**2)
    
    return I
```",0.45
64,Please calculate the Julian Date (JD) for the date 2031-9-5 07:23:12,Julian Date $JD = 2463114.80778$,"```python
def execute_code():
    # Given date: 2031-9-5 07:23:12
    year = 2031
    month = 9
    day = 5
    hour = 7
    minute = 23
    second = 12
    
    # Adjust for months January and February
    if month <= 2:
        year -= 1
        month += 12
    
    # Calculate the Julian Date
    A = year // 100
    B = 2 - A + (A // 4)
    
    # Julian Day Number for the date at 00:00 UTC
    JD = int(365.25 * (year + 4716)) + int(30.6001 * (month + 1)) + day + B - 1524.5
    
    # Add the time of day as a fraction of a day
    day_fraction = (hour + minute / 60.0 + second / 3600.0) / 24.0
    
    result = JD + day_fraction
    return result
```",0.51
65,"Please calculate the Local Sidereal Time (LST), given Greenwich Sidereal Time (GST)=18.29 hours, longitude λ=61.38°, and time difference=-0.66 hours",The Local Sidereal Time is $LST = 21.7218$ hours,"```python
def execute_code():
    # Given values
    GST = 18.29  # Greenwich Sidereal Time in hours
    longitude_deg = 61.38  # longitude in degrees
    time_diff = -0.66  # time difference in hours
    
    # Convert longitude from degrees to hours (15 degrees = 1 hour)
    longitude_hours = longitude_deg / 15.0
    
    # Calculate Local Sidereal Time (LST)
    # LST = GST + longitude (in hours)
    # Note: For east longitude, we add; for west longitude, we subtract
    # Since the longitude is given as positive 61.38°, we assume it's east longitude
    LST = GST + longitude_hours
    
    # Handle the time difference if needed
    # The time difference might be used to adjust GST, but typically LST = GST + longitude
    # However, if the time difference is meant to adjust the GST first:
    # GST_adjusted = GST + time_diff
    # LST = GST_adjusted + longitude_hours
    
    # Based on standard astronomical formula: LST = GST + λ (where λ is in hours, positive for east)
    # The time difference might be extraneous or already accounted for in GST
    # But since it's given, let's consider if GST needs to be adjusted by time_diff
    # Actually, looking at the problem again, the time difference might be the difference 
    # between local time and GMT, but for sidereal time calculation, we use:
    # LST = GST + longitude_in_hours
    
    # Let's stick with the standard formula
    LST = GST + longitude_hours
    
    # Normalize LST to be within 0-24 hours
    LST = LST % 24
    
    return LST
```",0.45
66,"Given the angular perturbation system:
\begin{cases}
\Delta \psi = \sum_i (A_i \sin \alpha_i + B_i \cos \alpha_i) \\
\Delta \epsilon = \sum_i (C_i \cos \alpha_i + D_i \sin \alpha_i)
\end{cases}
where the specific parameters are:
[(-0.0022787478155803786, 0.043000668903179495, -0.03449537932501712, 0.09905712146854748)]
Now, provide an expansion system.","The expanded system is:\Delta \psi = -0.002\sin\alpha_1 + 0.043\cos\alpha_1 \\
\Delta \epsilon = -0.034\cos\alpha_1 + 0.099\sin\alpha_1","```python
def execute_code():
    # Given parameters as a list of tuples (A_i, B_i, C_i, D_i)
    parameters = [(-0.0022787478155803786, 0.043000668903179495, -0.03449537932501712, 0.09905712146854748)]
    
    # Since we have only one term in the sum (i=1), we can write the expansion directly
    # The expansion system is:
    # Δψ = A₁ sin(α₁) + B₁ cos(α₁)
    # Δε = C₁ cos(α₁) + D₁ sin(α₁)
    
    A1, B1, C1, D1 = parameters[0]
    
    # Create the expansion system as a string representation
    delta_psi_expansion = f""Δψ = {A1:.15f} * sin(α₁) + {B1:.15f} * cos(α₁)""
    delta_epsilon_expansion = f""Δε = {C1:.15f} * cos(α₁) + {D1:.15f} * sin(α₁)""
    
    expansion_system = {
        ""delta_psi"": delta_psi_expansion,
        ""delta_epsilon"": delta_epsilon_expansion
    }
    
    return expansion_system
```",0.39
67,"Given the equatorial coordinates of a celestial object $\alpha=12.84^\circ$, $\delta=13.26^\circ$, and the obliquity of the ecliptic $\varepsilon=24.24^\circ$, use the following system of equations to compute the ecliptic coordinates $(\beta,\lambda)$:
\begin{cases}
\sin\beta = \sin\delta \cos\varepsilon - \cos\delta \sin\varepsilon \sin\alpha \\
\cos\beta \cos\lambda = \cos\delta \cos\alpha \\
\cos\beta \sin\lambda = \sin\delta \sin\varepsilon + \cos\delta \cos\varepsilon \sin\alpha
\end{cases}","Ecliptic coordinates $\beta = 6.91^\circ$, $\lambda = 17.07^\circ$","```python
import math

def execute_code():
    # Given values in degrees
    alpha_deg = 12.84
    delta_deg = 13.26
    epsilon_deg = 24.24
    
    # Convert to radians
    alpha = math.radians(alpha_deg)
    delta = math.radians(delta_deg)
    epsilon = math.radians(epsilon_deg)
    
    # Calculate sin(beta)
    sin_beta = math.sin(delta) * math.cos(epsilon) - math.cos(delta) * math.sin(epsilon) * math.sin(alpha)
    
    # Calculate cos(beta) * cos(lambda)
    cos_beta_cos_lambda = math.cos(delta) * math.cos(alpha)
    
    # Calculate cos(beta) * sin(lambda)
    cos_beta_sin_lambda = math.sin(delta) * math.sin(epsilon) + math.cos(delta) * math.cos(epsilon) * math.sin(alpha)
    
    # Calculate beta (ecliptic latitude)
    beta = math.asin(sin_beta)
    
    # Calculate lambda (ecliptic longitude) using atan2
    lambda_rad = math.atan2(cos_beta_sin_lambda, cos_beta_cos_lambda)
    
    # Convert results back to degrees
    beta_deg = math.degrees(beta)
    lambda_deg = math.degrees(lambda_rad)
    
    # Normalize lambda to [0, 360) range
    if lambda_deg < 0:
        lambda_deg += 360
    
    result = {""beta"": beta_deg, ""lambda"": lambda_deg}
    return result
```",0.45
68,"Given the reference angle $\theta_0=242.93^\circ$, observation distance $D=61.13$ meters, displacement vector $\mathbf{r}=(6.68, -9.27, -9.52)$ meters, and normal vector $\hat{n}=(-0.5720, -0.8200, -0.0194)$, please compute the total angle using the formula:
$\theta = \theta_0 + \frac{\mathbf{r} \cdot \hat{n}}{D}$",Total angle $\theta = 246.6505^\circ$,"```python
def execute_code():
    import math
    
    # Given values
    theta_0 = 242.93  # degrees
    D = 61.13  # meters
    r = [6.68, -9.27, -9.52]  # displacement vector in meters
    n_hat = [-0.5720, -0.8200, -0.0194]  # normal vector
    
    # Calculate dot product r · n_hat
    dot_product = sum(r_i * n_i for r_i, n_i in zip(r, n_hat))
    
    # Calculate the angle correction term
    angle_correction = dot_product / D
    
    # Calculate total angle
    theta = theta_0 + angle_correction
    
    return theta
```",0.45
69,"Given the UTC time 2023-03-27 19:17:38 and the leap second correction ΔAT = 10 seconds, use the following time system conversion formulae to calculate TAI and TT:
\begin{cases}
TAI = UTC + \Delta AT \\
TT = TAI + 32.184\ \mathrm{seconds}
\end{cases}","TAI time = 2023-03-27 19:17:48
TT time = 2023-03-27 19:18:20","```python
def execute_code():
    from datetime import datetime, timedelta
    
    # Given UTC time
    utc_time_str = ""2023-03-27 19:17:38""
    utc_time = datetime.strptime(utc_time_str, ""%Y-%m-%d %H:%M:%S"")
    
    # Given leap second correction
    delta_at = 10  # seconds
    
    # Calculate TAI = UTC + ΔAT
    tai_time = utc_time + timedelta(seconds=delta_at)
    
    # Calculate TT = TAI + 32.184 seconds
    tt_time = tai_time + timedelta(seconds=32.184)
    
    # Return results as formatted strings
    tai_result = tai_time.strftime(""%Y-%m-%d %H:%M:%S"") + f"".{int((tai_time.microsecond / 1e6) * 1000):03d}""
    tt_seconds = int(tt_time.second)
    tt_microseconds = tt_time.microsecond
    tt_fractional = tt_seconds + tt_microseconds / 1e6
    tt_result = tt_time.strftime(""%Y-%m-%d %H:%M:"") + f""{tt_fractional:.3f}""
    
    result = {
        ""TAI"": tai_result,
        ""TT"": tt_result
    }
    
    return result
```",0.39
